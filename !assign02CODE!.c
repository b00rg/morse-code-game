#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ctype.h>

#include "hardware/watchdog.h"
#include "hardware/gpio.h"
#include "hardware/pio.h"
#include "pico/stdlib.h"
#include "pico/time.h"
#include "ws2812.pio.h"

#define maxBufferSize 100
#define IS_RGBW true        // Will use RGBW format
#define NUM_PIXELS 1        // There is 1 WS2812 device in the chain
#define WS2812_PIN 28       // The GPIO pin that the WS2812 connected to

void start();
void user_input(int inputChar);
void iterate_level();
void level_one();
void level_two();
void level_three();
void level_four();
void game_over_win();
void game_over_lose();

void game_menu();
void main_game_loop();
void update_highest_streak(int current_streak);
void main_asm();

void asm_gpio_init(uint pin) {
  gpio_init(pin);
}

void asm_gpio_set_dir(uint pin, bool out) {
  gpio_set_dir(pin, out);
}

bool asm_gpio_get(uint pin) {
  return gpio_get(pin);
}

void asm_gpio_put(uint pin, bool value) {
  gpio_put(pin, value);
}

void asm_gpio_set_irq(uint pin) {
  gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true);
}

uint32_t timeus() {
  return time_us_32();
}

/**
 * @brief Wrapper function used to call the underlying PIO
 *        function that pushes the 32-bit RGB colour value
 *        out to the LED serially using the PIO0 block. The
 *        function does not return until all of the data has
 *        been written out.
 * 
 * @param pixel_grb The 32-bit colour value generated by urgb_u32()
 */
static inline void put_pixel(uint32_t pixel_grb) {
  pio_sm_put_blocking(pio0, 0, pixel_grb << 8u);
}

/**
 * @brief Function to generate an unsigned 32-bit composit GRB
 *        value by combining the individual 8-bit paramaters for
 *        red, green and blue together in the right order.
 * 
 * @param r     The 8-bit intensity value for the red component
 * @param g     The 8-bit intensity value for the green component
 * @param b     The 8-bit intensity value for the blue component
 * @return uint32_t Returns the resulting composit 32-bit RGB value
 */
static inline uint32_t urgb_u32(uint8_t r, uint8_t g, uint8_t b) {
  return  ((uint32_t) (r) << 8)  |
          ((uint32_t) (g) << 16) |
          (uint32_t) (b);
}


// Global Variables
int lives;
int currentLevel;
bool inputComplete = 0;
int i;
int inputSize; // NOTE: Please change this number to the maximum input for the array
int totalLevels;
int score;
int score_streak;
int top_streak;
char buffer[maxBufferSize];  
char input[maxBufferSize];  
int buffer_pos = 0;

void reset_buffer() {
  memset(buffer, 0, sizeof(char)*maxBufferSize);
  buffer_pos = 0;
}

/*
    Morse code table
*/
typedef struct
{
    char letter;
    char *morseCode;
} MorseAlphabet;

// Initialize the morseTable with the characters and their Morse codes
MorseAlphabet morseTable[] = {
    {'A', ".-"},
    {'B', "-..."},
    {'C', "-.-."},
    {'D', "-.."},
    {'E', "."},
    {'F', "..-."},
    {'G', "--."},
    {'H', "...."},
    {'I', ".."},
    {'J', ".---"},
    {'K', "-.-"},
    {'L', ".-.."},
    {'M', "--"},
    {'N', "-."},
    {'O', "---"},
    {'P', ".--."},
    {'Q', "--.-"},
    {'R', ".-."},
    {'S', "..."},
    {'T', "-"},
    {'U', "..-"},
    {'V', "...-"},
    {'W', ".--"},
    {'X', "-..-"},
    {'Y', "-.--"},
    {'Z', "--.."},
    {'1', ".----"},
    {'2', "..---"},
    {'3', "...--"},
    {'4', "....-"},
    {'5', "....."},
    {'6', "-...."},
    {'7', "--..."},
    {'8', "---.."},
    {'9', "----."},
    {'0', "-----"}};

typedef struct
{
    char *word;
    char *morseCode;
    char *answers;

} MorseWord;

MorseWord morseWordTable[] = {
    // feel free to add more here.
    {"HELLO", ".... . .-.. .-.. ---", "1. ..-. -.. .... .... .\n2. .... . .-.. .-.. ---\n3. .-. .-- -- -- ...\n\n"},
    {"WORLD", ".-- --- .-. .-.. -..", "1. .-- --- .-. .-.. -..\n2. -... -. .-. -.. ...\n3. --.- .. .-. -..- ..-.\n\n"},
    {"MORSE", "-- --- .-. ... .", "1. --.. .... ... .- --.-\n2. .--. ..-. --.- -.-. ...\n3. -- --- .-. ... .\n\n"},
    {"CODE", "-.-. --- -.. .", "1. .--. -.. ... --.- \n2. -.-. --- -.. .\n3. -- -.. --.- .\n\n"},
    {"MICRO", "-- .. -.-. .-. ---", "1. -- .. -.-. .-. ---\n2. ..-. ... -.. .-. -.\n3. -.-. ..-. -... -.. -..- --..\n\n"},
    {"PROCESSOR", ".--. .-. --- -.-. . ... ... --- .-.", "1. -.-. ... ..-. -.- -..- -..- ... .-.\n2. --.. -.. .. ... ... --.- -.-. ..- .-.\n3. .--. .-. --- -.-. . ... ... --- .-.\n\n"},
    {"RASPBERRY", ".-. .- ... .--. -... . .-. .-. -.--", "1. -..- .- ... .--- .-- ..- ..- ...-\n2. --.. .... -. -.- --.- -.. -.. --\n3. .-. .- ... .--. -... . .-. .-. -.--\n\n"},
    {"PI", ".--. ..", "1. -..- .-\n 2. .--. ..\n 3. .--- -.-\n\n"},
    {"PICO", ".--. .. -.-. ---", "1. .--. .. -.-. ---\n 2. ...- .-- -.-- ...-\n 3. .--- .- ..-. -...\n\n"},
};

/**
 * @brief Initializes and starts the game.
 *
 * This function sets up the initial game state, including:
 * - Displaying a welcome message and game title in ASCII art.
 * - Setting the initial number of player lives to 3.
 * - Setting the starting level to 0 (to begin at Level 1 in the `iterate_level` function).
 * - Setting the initial size for the user input buffer.
 * - Setting the total number of playable levels to 4.
 * - Initializing the player's score and score streak to 0.
 * - Dynamically allocating memory for the user input buffer.
 * - Handling potential memory allocation failures.
 */
void start()
{
    printf("\n"); // start ascii print
    printf("  _____                                             \n");
    printf(" |_   _|                                            \n");
    printf("   | |       .---.   ,--.    _ .--.   _ .--.       \n");
    printf("   | |   _  / /__\\\\ `'_\\ :  [ `/'`\\] [ `.-. |      \n");
    printf("  _| |__/ | | \\__., // | |,  | |      | | | |      \n");
    printf(" |________|  '.__.' \'-;__/ [___]    [___||__]     \n");
    printf("                                                    \n");
    printf(" ____    ____                                      \n");
    printf("|_   \\  /   _|                                      \n");
    printf("  |   \\/   |     .--.    _ .--.   .--.    .---.    \n");
    printf("  | |\\  /| |   / .'`\\ \\ [ `/'`\\] ( (`\\]  / /__\\\\   \n");
    printf(" _| |_\\/|_ |_  | \\__. |  | |      `'.'.  | \\__.,   \n");
    printf("|_____||_____|  '.__.'  [___]    [\\__) )  '.__.'     \n");
    printf("                                                    \n");
    printf("   ______                  __                      \n");
    printf(" .' ___  |                |  ]                     \n");
    printf("/ .'   \\_|   .--.     .--.| |   .---.              \n");
    printf("| |        / .'`\\ \\ / /'`\\' |  / /__\\\\             \n");
    printf("\\ `.___.'\\ | \\__. | | \\__/  |  | \\__.|             \n");
    printf(" `.____ .'  '.__.'   '.__.;__]  '.__.'             \n\n\n");
    printf("   ___                              _____  ____  \n");
    printf("  / _ \\ _ __   ___   _   _  _ __   |___ / | ___| \n");
    printf(" / /_\\/| '__| / _ \\ | | | || '_ \\    |_ \\ |___ \\ \n");
    printf("/ /_\\\\ | |   | (_) || |_| || |_) |  ___) | ___) |\n");
    printf("\\____/ |_|    \\___/  \\__,_|| .__/  |____/ |____/ \n");
    printf("                           |_|                    \n\n");

    put_pixel(urgb_u32(0x00, 0xFF, 0x00));           // Set the RGB LED color to green
    lives = 3;        // Set lives to 3
    totalLevels = 4;  // change this to the total number of levels. Currently 2 for the 2 levels.
    score = 0;
    score_streak = 0;
}
/**
 * @brief A watchdog timer that automatically resets the raspberry pi pico program
 *        if unresponsive for 7 seconds or crashes
 *        Will print if reset is caused by watchdog
 *
 */
void watchdog_init()
{
    if (watchdog_caused_reboot())
    { // Check if reset was due to watchdog timeout
        printf("\n Watchdog Reset : No input detected");
    }
    if (watchdog_enable_caused_reboot())
    { // Check if enabling watchdog caused reset
        printf("\n Watchdog Reset : Enable watchdog");
    }
    watchdog_enable(7000, 0); // Enable the watchdog timer with 7000ms timeout (7 seconds), pause on debug
    watchdog_update();        // Reset watchdog to prevent a reset
}

/**
 * @brief Processes individual user input characters for Morse code entry.
 *
 * This function takes an integer representing a user action (e.g., pressing a button for a dot, dash, space, or enter)
 * and appends the corresponding Morse code character to the `input` buffer. It also handles the completion
 * of an input sequence and triggers the level evaluation.
 *
 * @param inputChar An integer representing the user's input action:
 * - 1: Represents a Morse code dot ('.').
 * - 2: Represents a Morse code dash ('-').
 * - 3: Represents a space (' ') to separate Morse code letters or words.
 * - 4: Represents the completion of the current Morse code input (equivalent to pressing ENTER).
 *
 * @details
 * - Checks if the input buffer is full to prevent buffer overflows. If it is, a "Input array full" message is printed.
 * - Uses a `switch` statement to handle different input characters:
 * - For cases 1, 2, and 3, the corresponding Morse code character is appended to the `input` buffer,
 * and the `i` index is incremented. The entered character is also printed to the console for feedback.
 * - For case 4, the `inputComplete` flag is set to 1, a newline and "Level finished" message are printed,
 * the `input` buffer is null-terminated, and the `iterate_level()` function is called to evaluate the input
 * and potentially advance to the next level.
 * - For any other invalid input character, an error message is printed, instructing the user on the valid input options.
 */
void user_input(int inputChar) {
  // Check if there's room in buffer
  if (buffer_pos >= maxBufferSize - 1) {
      printf("\nBuffer full - clearing\n");
      buffer_pos = 0;
      return;
  }

  watchdog_update();

  switch(inputChar) {
    case 1: //dot
      buffer[buffer_pos] = '.';
      buffer_pos ++;
      buffer[buffer_pos] = '\0';  // Null terminate
      printf(".");
      break;

    case 2: //dash
      buffer[buffer_pos] = '-';
      buffer_pos ++;
      buffer[buffer_pos] = '\0';  // Null terminate
      printf("-");
      break;

    case 3: //space
      buffer[buffer_pos] = ' ';
      buffer_pos ++;
      buffer[buffer_pos] = '\0'; // Null terminate
      printf(" "); 
      break;

    case 4:
      if(buffer_pos>0)            // If buffer isnt empty, copy to input
        strcpy(input, buffer);
      inputComplete = true;       // Input is now complete
      reset_buffer();
      printf("\n");
      break;
  }
}

/**
 * @brief Advances the game to the next level or triggers the game over sequence.
 *
 * This function increments the `currentLevel` counter and resets the `inputComplete` flag and the input buffer index `i`.
 * It then checks if all levels have been completed. If so, it calls the `game_over_win()` function.
 * Otherwise, it uses a `switch` statement to call the appropriate level execution function based on the
 * `currentLevel`. If `currentLevel` exceeds the `totalLevels`, it indicates an error in the game flow.
 */
void iterate_level()
{
    currentLevel += 1;
    if (currentLevel > totalLevels)
    {
        game_over_win();
        return;
    }
    switch (currentLevel)
    {
    case 1:
        level_one();
        break;
    case 2:
        level_two();
        break;
    case 3:
        level_three();
        break;
    case 4:
        level_four();
        break;
    default:
        printf("Error!!! This means there is a bug in the code");
        break;
    }
}

/**
 * @brief Executes Level 1 of the Morse code game.
 *
 * This level tests the user's ability to recognize Morse code for individual letters.
 * The game presents a random Morse code sequence and prompts the user to enter the
 * corresponding letter. The user has a limited number of lives and the level
 * progresses based on the score.
 *
 * @details
 * - Prints a Level 1 header.
 * - Enters a loop that continues as long as the user has lives remaining and the score is less than 5.
 * - Seeds the random number generator.
 * - Randomly selects a letter and its Morse code from the `morseTable`.
 * - Prompts the user to type the letter corresponding to the displayed Morse code.
 * - Reads the user's input.
 * - Converts the user's input to uppercase for case-insensitive comparison.
 * - Checks if the user's input matches the correct letter.
 * - If correct:
 * - Increments the score.
 * - Increments the score streak.
 * - Updates the highest score streak.
 * - Prints a "Correct!" message and the current score and streak.
 * - If incorrect:
 * - Decrements the number of lives.
 * - Resets the score streak.
 * - Prints an "Incorrect" message, the correct answer, and the remaining lives, score, and streak.
 */

void level_one()
{

    printf("   __                    __       ___\n"); // Level 1 print statement
    printf("  / /  ___  _  __ ___   / /      <  /\n");
    printf(" / /__/ -_)| |/ // -_) / /       / / \n");
    printf("/____/\\__/ |___/ \\__/ /_/       /_/  \n");
    printf("                                      \n");
    while (lives > 0 && score < 5)
    {                                                         // change this to 5 after
        srand(time(NULL));                                    // Seed the random number generator
        int letterIndex = rand() % 36;                        // Generate a random number between 0 and 35 (inclusive)
        MorseAlphabet selectedChar = morseTable[letterIndex]; // Get the corresponding character from the table
        printf("=========================================\n");
        printf(" Type the morse code for the following letter %c: %s : ",selectedChar.letter , selectedChar.morseCode);
        reset_buffer();
        inputComplete = false;
        while(!inputComplete){
          sleep_ms(200);
        }
    
        watchdog_update();
        
        printf("\n=============================================\n");
        printf(" You entered: %s\n", input);
        printf("=============================================\n");

        if (strcmp(input, selectedChar.morseCode) == 0)
        {
            printf("Correct!\n");
            score++;
            score_streak++;
            update_highest_streak(score_streak);

            printf("Current Score : %d, Current Streak : %d \n", score, score_streak);
        }
        else
        {
            lives -= 1;
            switch (lives)
            {
            case 2:
              put_pixel(urgb_u32(0xFF, 0xFF, 0x00));
              break;

            case 1:
              put_pixel(urgb_u32(0xFF, 0x4D, 0x00));
              break;

            case 0:
              put_pixel(urgb_u32(0xFF, 0x00, 0x00));
              break;
            }
            score_streak = 0;
            printf("The correct answer was %s. You have %d lives left\n", selectedChar.morseCode, lives);
            printf("Current Score : %d, Current Streak : %d \n", score, score_streak);
        }
    }
}


/**
 * @brief Executes Level 2 of the Morse code game.
 *
 * This level tests the user's ability to translate individual letters into Morse code.
 * The game presents a random letter and prompts the user to enter the
 * corresponding Morse code sequence. The user has a limited number of lives and the
 * level progresses based on the score.
 *
 * @details
 * - Prints a Level 2 header.
 * - Enters a loop that continues as long as the user has lives remaining and the score is less than 10.
 * - Seeds the random number generator.
 * - Randomly selects a letter and its Morse code from the `morseTable`.
 * - Prompts the user to type the Morse code corresponding to the displayed letter.
 * - Reads the user's input.
 * - Checks if the user's input matches the correct Morse code.
 * - If correct:
 * - Increments the score.
 * - Increments the score streak.
 * - Updates the highest score streak.
 * - Prints a "Correct!" message and the current score and streak.
 * - If incorrect:
 * - Decrements the number of lives.
 * - Resets the score streak.
 * - Prints an "Incorrect" message, the correct answer, and the remaining lives, score, and streak.
 */
void level_two()
{

    printf("   __                    __        ___ \n"); // Level 2 print statement
    printf("  / /  ___  _  __ ___   / /       |_  |\n");
    printf(" / /__/ -_)| |/ // -_) / /       / __/ \n");
    printf("/____/\\__/ |___/ \\__/ /_/       /____/ \n");
    printf("                                        \n");
    while (lives > 0 && score < 10)
    {                                  // change score to 10 here maybe after changin level 1 back to 5. here for debugging purposes; do not keep in final code
        srand(time(NULL));             // Seed the random number generator
        int letterIndex = rand() % 36; // Generate a random number between 0 and 35 (inclusive)
        MorseAlphabet selectedChar = morseTable[letterIndex];
        printf("=========================================\n");
        printf("Type the morse code for the following letter: \n");
        printf("Morse code: %c\n", selectedChar.letter);

        reset_buffer();
        inputComplete = false;
        while(!inputComplete){
          sleep_ms(200);
        }

        watchdog_update();

        printf("\n=============================================\n");
        printf(" You entered: %s\n", input);
        printf("=============================================\n");
        input[strcspn(input, "\n")] = 0; // removes new line

        if (strcmp(input, selectedChar.morseCode) == 0)
        {
            printf("Correct! \n");
            score++;
            score_streak++;
            update_highest_streak(score_streak);

            printf("Current Score : %d, Current Streak : %d \n", score, score_streak);

            // break;
        }
        else
        {
            lives -= 1;
            switch (lives)
            {
            case 2:
              put_pixel(urgb_u32(0xFF, 0xFF, 0x00));
              break;

            case 1:
              put_pixel(urgb_u32(0xFF, 0x4D, 0x00));
              break;

            case 0:
              put_pixel(urgb_u32(0xFF, 0x00, 0x00));
              break;
            }
            score_streak = 0;
            printf("Incorrect. The correct answer was '%s'. You have %d lives left\n", selectedChar.morseCode, lives);
            printf("Current Score : %d, Current Streak : %d \n", score, score_streak);
        }
    }
}


/**
 * @brief Executes Level 3 of the Morse code game.
 *
 * This level introduces the user to Morse code for entire words.
 * The game presents a random word and a set of possible Morse code translations,
 * prompting the user to enter the correct Morse code sequence for the word.
 * The user has a limited number of lives and the level progresses based on the score.
 *
 * @details
 * - Prints a Level 3 header.
 * - Enters a loop that continues as long as the user has lives remaining and the score is less than 15.
 * - Seeds the random number generator.
 * - Randomly selects a word and its Morse code from the `morseWordTable`.
 * - Prompts the user to type the Morse code corresponding to the displayed word.
 * - Displays a list of possible Morse code solutions.
 * - Reads the user's input using `fgets` to handle potential spaces in the input.
 * - Removes the trailing newline character from the input.
 * - Checks if the user's input matches the correct Morse code for the word.
 * - If correct:
 * - Increments the score.
 * - Increments the score streak.
 * - Updates the highest score streak.
 * - Prints a "Correct!" message and the current score and streak.
 * - If incorrect:
 * - Decrements the number of lives.
 * - Resets the score streak.
 * - Prints an "Incorrect" message, the correct word, and the remaining lives, score, and streak.
 */
void level_three()
{
    srand(time(NULL));
    printf("   __                    __        ____  \n"); // print statement level 3
    printf("  / /  ___  _  __ ___   / /       |_  /  \n");
    printf(" / /__/ -_)| |/ // -_) / /       _/_ <  \n");
    printf("/____/\\__/ |___/ \\__/ /_/       /____/  \n");
    printf("                                        \n");
    while (lives > 0 && score < 15)
    {
        int wordIndex = rand() % (sizeof(morseWordTable) / sizeof(morseWordTable[0]));
        MorseWord selectedWord = morseWordTable[wordIndex];
        printf("=========================================\n");
        printf(" Type the Morse code for the word: %s\n", selectedWord.word);
        printf("=========================================\n");
        printf("Pick from the below: \n"); // Basically the morse code word is picked from a table above and all morse code solutions are shown below
        printf("%s", selectedWord.answers);
        printf("=========================================\n");

        reset_buffer();
        inputComplete = false;
        while(!inputComplete){
          sleep_ms(200);
        }

        watchdog_update();

        printf("\n=============================================\n");
        printf(" You entered: %s\n", input);
        printf("=============================================\n");
        if (strcmp(input, selectedWord.morseCode) == 0)
        {
            printf("Correct! \n");
            score++;
            score_streak++;
            update_highest_streak(score_streak);
            printf("Current Score : %d, Current Streak : %d \n", score, score_streak);

            // break;
        }
        else
        {
            lives -= 1;
            switch (lives)
            {
            case 2:
              put_pixel(urgb_u32(0xFF, 0xFF, 0x00));
              break;

            case 1:
              put_pixel(urgb_u32(0xFF, 0x4D, 0x00));
              break;

            case 0:
              put_pixel(urgb_u32(0xFF, 0x00, 0x00));
              break;
            }
            score_streak = 0;
            printf("Incorrect. The correct answer was %s. You have %d lives left\n", selectedWord.word, lives);
            printf("Current Score : %d, Current Streak : %d \n", score, score_streak);
        }
    }
}


/**
 * @brief Executes Level 4 of the Morse code game.
 *
 * This level continues to test the user's ability to translate words into Morse code.
 * The game presents a random word and prompts the user to enter the
 * corresponding Morse code sequence. The user has a limited number of lives and the
 * level progresses based on the score.
 *
 * @details
 * - Prints a Level 4 header.
 * - Enters a loop that continues as long as the user has lives remaining and the score is less than 20.
 * - Seeds the random number generator.
 * - Randomly selects a word and its Morse code from the `morseWordTable`.
 * - Prompts the user to type the Morse code corresponding to the displayed word.
 * - Reads the user's input using `fgets`.
 * - Removes the trailing newline character from the input.
 * - Checks if the user's input matches the correct Morse code for the word.
 * - If correct:
 * - Increments the score.
 * - Increments the score streak.
 * - Updates the highest score streak.
 * - Prints a "Correct!" message and the current score and streak.
 * - If incorrect:
 * - Decrements the number of lives.
 * - Resets the score streak.
 * - Prints an "Incorrect" message, the correct word, and the remaining lives, score, and streak.
 */
void level_four()
{
    srand(time(NULL));

    printf("   __                    __       ____  \n"); // print statemnet level 4
    printf("  / /  ___  _  __ ___   / /      / / /  \n");
    printf(" / /__/ -_)| |/ // -_) / /      /_  _/  \n");
    printf("/____/\\__/ |___/ \\__/ /_/        /_/   \n");
    printf("                                       \n");

    while (lives > 0 && score < 20)
    { // change this to 15 after debugging; after level 2 is changed to 10 and level 1 is changed to 5
        int wordIndex = rand() % (sizeof(morseWordTable) / sizeof(morseWordTable[0]));
        MorseWord selectedWord = morseWordTable[wordIndex];
        printf("=========================================\n");
        printf(" Type the Morse code for the word: %s\n", selectedWord.word);
        printf("=========================================\n");

        reset_buffer();
        inputComplete = false;
        while(!inputComplete){
          sleep_ms(200);
        }

        watchdog_update();

        printf("\n=============================================\n");
        printf(" You entered: %s\n", input);
        printf("=============================================\n");
        if (strcmp(input, selectedWord.morseCode) == 0)
        {
            printf("Correct! \n");
            score++;
            score_streak++;

            update_highest_streak(score_streak);
            printf("Current Score : %d, Current Streak : %d \n", score, score_streak);
            // break;
        }
        else
        {
            lives -= 1;
            switch (lives)
            {
            case 2:
              put_pixel(urgb_u32(0xFF, 0xFF, 0x00));
              break;

            case 1:
              put_pixel(urgb_u32(0xFF, 0x4D, 0x00));
              break;

            case 0:
              put_pixel(urgb_u32(0xFF, 0x00, 0x00));
              break;
            }
            score_streak = 0;
            printf("Incorrect. The correct answer was %s. You have %d lives left\n", selectedWord.word, lives);
            printf("Current Score : %d, Current Streak : %d \n", score, score_streak);
        }
    }
}
/**
 * @brief Updates the highest score streak achieved by the player.
 *
 * This function compares the current score streak with the highest streak recorded
 * so far and updates the highest streak if the current streak is greater.
 *
 * @param current_streak The current consecutive correct answer streak.
 */
void update_highest_streak(int current_streak)
{
    if (current_streak > top_streak)
    {
        top_streak = current_streak;
    }
}

/**
 * @brief Displays the "Game Over - Win" screen and handles post-win actions.
 *
 * This function is called when the player successfully completes all the levels
 * or reaches the winning score condition. It displays a congratulatory message
 * along with the final score and the highest score streak achieved. It then
 * frees the dynamically allocated input buffer (if any) and returns to the game menu.
 */
void game_over_win()
{
    printf("\n"); // win ascii print
    printf("_____.___.               __      __.__      ._.\n");
    printf("\\__  |   | ____  __ __  /  \\    /  \\__| ____| |\n");
    printf(" /   |   |/  _ \\|  |  \\ \\   \\/\\/   /  |/    \\ |\n");
    printf(" \\____   (  <_> )  |  /  \\        /|  |   |  \\|\n");
    printf(" / ______|\\____/|____/    \\__/\\  / |__|___|  /_\n");
    printf(" \\/                            \\/          \\/\\/ \n");
    printf("\n=======================================================================\n");
    printf("============================= FINAL SCORE: %d ==========================\n", score);
    printf("===========================+ HIGHEST STREAK: %d ==========================\n", top_streak);
    printf("=======================================================================\n");

    game_menu();
    return;
}

/**
 * @brief Displays the "Game Over - Lose" screen and handles post-loss actions.
 *
 * This function is called when the player runs out of lives. It displays a
 * "Game Over" message along with the final score and the highest score streak
 * achieved. It then frees the dynamically allocated input buffer (if any) and
 * returns to the game menu.
 */
void game_over_lose()
{
    printf("\n"); // game over ascii print
    printf("  ________                        ________                     \n");
    printf(" /  _____/_____    _____   ____   \\_____  \\___  __ ___________ \n");
    printf("/   \\  ___\\__  \\  /     \\_/ __ \\   /   |   \\  \\/ // __ \\_  __ \\\n");
    printf("\\    \\_\\  \\/ __ \\|  Y Y  \\  ___/  /    |    \\   /\\  ___/|  | \\/\n");
    printf(" \\______  (____  /__|_|  /\\___  > \\_______  /\\_/  \\___  >__|   \n");
    printf("        \\/     \\/      \\/     \\/          \\/          \\/       \n");
    printf("\n=======================================================================\n");
    printf("============================ FINAL SCORE: %i ==========================\n", score);
    printf("===========================+ HIGHEST STREAK: %d ==========================\n", top_streak);
    printf("=======================================================================\n");

    game_menu();
    return;
}

/**
 * @brief Displays the main game menu and handles user input for navigation.
 *
 * This function presents the user with options to start a new game, select a specific
 * level, or exit the game. It continuously loops until a valid option is chosen.
 * The user is expected to input their choice using Morse code representations
 * for the menu options.
 *
 * @details
 * - Prints the game menu header and available options with their Morse code inputs.
 * - Prompts the user to enter their choice.
 * - Reads the user's input using `scanf`.
 * - Compares the user's input with the Morse code for each menu option:
 * - "." : Starts a new game by setting `currentLevel` to 0 and calling `main_game_loop()`.
 * - "-.-" : Displays a sub-menu for level selection:
 * - ".." : Starts Level 1 by setting `currentLevel` to 0 and calling `main_game_loop()`.
 * - "--" : Starts Level 2 by setting `currentLevel` to 1 and calling `main_game_loop()`.
 * - ".-" : Starts Level 3 by setting `currentLevel` to 2 and calling `main_game_loop()`.
 * - "-." : Starts Level 4 by setting `currentLevel` to 3 and calling `main_game_loop()`.
 * - If an invalid level selection is entered, it prints an error message and returns to the main menu.
 * - "---" : Exits the game by printing a farewell message and calling `exit(0)`.
 * - If the user enters an invalid Morse code for the main menu, it prints an error message and redisplays the menu.
 */
void game_menu()
{
    printf("\n=================== GAME MENU ===================\n");
    printf(". : Start Game\n");
    printf("-.- : Start at Specific Level\n");
    printf("--- :  Exit\n");
    printf("Enter your choice in Morse using the Button: \n");
    
    inputComplete = false;
    while(!inputComplete){
      sleep_ms(200);
    }

    if (strcmp(input, ".") == 0)
    {
        printf("Starting new game...\n");
        
        currentLevel = 0;
        main_game_loop();
    }
    else if (strcmp(input, "-.-") == 0)
    {
        printf("\nLevel Select:\n\n");
        printf(".. : Level one\n");
        printf("-- : Level two\n");
        printf(".- : Level three\n");
        printf("-. : Level four\n");

        reset_buffer();
        inputComplete = false;
        while(!inputComplete){
          sleep_ms(200);
        }
        printf("%s\n", input);
        if (strcmp(input, "..") == 0)
        {
            currentLevel = 0;
            main_game_loop();
        }
        else if (strcmp(input, "--") == 0)
        {
            currentLevel = 1;
            main_game_loop();
        }
        else if (strcmp(input, ".-") == 0) {
            currentLevel = 2;
            main_game_loop();
        }
        else if (strcmp(input, "-.") == 0) {
            currentLevel = 3;
            main_game_loop();
        }
    }
    else if (strcmp(input, "---") == 0)
    {
        printf("Exiting the game, Thank you for playing!\n");
        exit(0);
    }
    else
    {
        printf("Invalid Input: '%s'. Try again\n", input);
        sleep_ms(1000);  // Add delay before returning to menu
        game_menu();
    }
}

/**
 * @brief The main loop that controls the flow of the Morse code game.
 *
 * This function initializes the game state, starts the first level, and then
 * iteratively calls the level execution functions until the player either runs
 * out of lives or completes all the levels. Finally, it calls the appropriate
 * game over function based on the outcome.
 *
 * @details
 * - Introduces a 5-second delay using `sleep_ms()`.
 * - Calls the `start()` function (presumably to initialize game variables like lives and score).
 * - Calls `iterate_level()` to begin the first level (Level 1).
 * - Enters a `while` loop that continues as long as the player has lives remaining
 * and the `currentLevel` is within the total number of levels.
 * - Inside the loop, it calls `iterate_level()` to progress to the next level.
 * - After the loop finishes, it checks the value of `lives`:
 * - If `lives` is less than or equal to 0, it calls `game_over_lose()`.
 * - Otherwise (if all levels were completed), it calls `game_over_win()`.
 */
void main_game_loop()
{   
    watchdog_update();
    start();
    iterate_level(); // Starts the game at Level 1

    while (lives > 0 && currentLevel <= totalLevels)
    {
        iterate_level(); // Go to next level
    }

    // Game over logic
    if (lives <= 0)
    {
        game_over_lose();
    }
    else
    {
        game_over_win();
    }
}



int main()
{
    stdio_init_all();
    // Initialise the PIO interface with the WS2812 code
    PIO pio = pio0;
    uint offset = pio_add_program(pio, &ws2812_program);
    ws2812_program_init(pio, 0, offset, WS2812_PIN, 800000, IS_RGBW);
    watchdog_init();
    main_asm();
    put_pixel(urgb_u32(0x00, 0x00, 0xFF));
    game_menu();
    return 0;
}

/**
 * @brief   Creation of a Game Menu:
 *
 *          Game menu:
 *  @          - Start Game
 *          - Start at a certain level
 *          - Exit
 *
 *          Restart Game Function:
 *          - Once game over_win/lose is called,
 *          - Either:
 *          1. Present the following options:
 *              - Back to menu
 *              - Exit
 *          2. Present only Back to menu, as the menu will have an exit function
 */
